\documentclass[11pt, a4paper]{book}
\usepackage{parskip}
\usepackage[top=1.5cm, left=1cm, right=1cm, bottom=2.5cm]{geometry}
\begin{document}
\chapter{Classes and Methods}
\section{Scroller}
\subsection{Class Overview}
This class encapsulates scrolling. The duration of the scroll can be passed
 in the constructor and specifies the maximum time that the scrolling animation
should take. Past this time, the scrolling is automatically moved to its final
stage and \verb|computeScrollOffset()| will always return false to indicate taht
scrolling is over.

\section{AppWdiget}

\subsection{AppWidgetManager}
Updates AppWidgetState, gets information about installed AppWidgetProviders and
other Widget related state.
\subsection{AppWidgetHost}
Provides the \emph{interaction} with the AppWidget source for apps, like the
home screen, that want to embed AppWidget in their UI.

You need to privde a hostid at construction, the hostId is a number of your 
choosing that should be internally unique to your app (that is, you don't 
need to worry about collisions with other apps on the system).  It's designed 
for cases where you want two unique AppWidgetHosts inside of the same 
application, so the system can optimize and only send updates to actively 
listening hosts. 

\subsection{AppWidgetHostView}
Provides teh glue to show AppWidgetViews. Offers automatic animation between
updates, and will try recycling old views for each incoming.
\subsection{AppWidgetProviderInfo}
Describes the meta data for an installed AppWidgetProvider. The fields
correspond to the fields in the \verb|appwidget-provider>| xml tag.


\section{Content Providers}
\subsection{Overview}
Content providers manage access to a \emph{structured set of data}. They
encapsulate the data, and provide mechanisms for defining data security. Content
providers are the standard interface that \emph{connets data in one process with
code running in another process.}

Use \verb|ContentResolver| Object in application's Context to communicate with
the provider as a client. 

\verb|ContentResolver| object communicates with the provider object, an instance
of a class that implements \emph{ContentProvider}. The provider object receives
data requests from clients. 

A content provider manages access to a central repository of data. A provider is
part of an Android application, which ofen privides its own UI for working with
the data. 

However, content providers are primarily intended to be \emph{used by other
applications}, which access teh provider using a provider client object. 

\subsection{Content URIs}
A content URI is a URI that indentifies data in a provider. Content URIs include
the symbolic name of teh entire provider (its authority) and name that points to
a table (a path).
\section{Handler}
A Handler allows you to send and process Message and Runnable objects associated
with a thread's MessageQueue

Each instance is aassociated with a single thread and that thread's message
queue.

When you create a Handler, it is bound to the thread/message queue of the thread
that is creating it -- from that point on, it will deliver messages and
runnables to that message queue and execute them as they come out of the message
queue. 

Two main uses:
\begin{enumerate}
\item To schedule messages and runnable to be executed as some point in the
future;
\item To enqueue an action to be performed on a different thread than your own.
\end{enumerate}

The \verb|post(Runnable)| allow you to enqueue Runnable objects to be called by
the messager queue when they are received;

The \verb|sendMessage(Message)| allow you to enqueue a Message object
containning a bundle of data that will be processed by the Handler's
\verb|handleMessage(Messsage)| method.

When posting or sending to a Hnadler, you can either allow the item to be
processed as soon as the message queue is ready to do so, or specify a dely. 
\begin{description}
\item[notifyChange] Notify registered obsevers that a row was updated. 
\end{description}
\section{ViewGroup}
\subsection{onInterceptTouchEvent}
Implement this method to intercept all touch screen \verb|MotionEvent|. This
allow you to \emph{watch event as they are dispatched to your children}, and
take the owner ship of teh current gesture at any point.

Events will be received in the following order:
\begin{enumerate}
\item You will receive the \textbf{down event} in \verb|onInterceptTouchEvent|
\item The \textbf{down event} will be handled either by a child of this view
group, or given to the \verb|ViewGroup|'s own \verb|onTouchEvent()| method to
handle. This means you should implement \verb|onTouchEvent()| to return
\verb|true|, so you will continue to see the rest of the gesture (instead of
looking for a parent view to handle it). Also by returning true from
\verb|onTouchEvent|, you will not receive any following events in
\verb|onInterceptTouchEvent()| and all touch processing must happen in
\verb|onTouchEvent()|
\item For as long as you return \verb|false| from \verb|onInterceptTouchEvent|,
each following event will be delivered first here and then to the target's
\verb|onTouchEvent()|
\item If you return \verb|true| here, you will not receive any following events,
the target view will receieve the same event but with the \verb|ACTION_CANCEL|
and all further events will be delivered to your \verb|onTouchEvent()| method
and no longer appear here.
\end{enumerate}

\end{document}
